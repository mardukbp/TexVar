%%%%%%%% Input CONFIG und Titelformatierung
\input{HEADER_Sem.tex}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
	language=[5.2]Lua,
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false,
	columns=flexible,
	basicstyle={\small\ttfamily},
	numberstyle=\tiny\color{gray},
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen},
	stringstyle=\color{mauve},
	breaklines=true,
	breakatwhitespace=true,
	tabsize=3
}
\begin{document}
\section{Library laden}
Laden von \lstinline$tVar$ und Festlegen eines Zahlenformates
\begin{lstlisting}
require("../tVar.lua")
matrix = require("../matrix")
tVar.numFormat = "%.3f"
\end{lstlisting}
\begin{luacode*}
	require("../tVar.lua")
	matrix = require("../matrix")
	tVar.numFormat = "%.3f"
\end{luacode*}
\section{U-Wert Berechnung}
Berechnung des U-Wertes eine Bauteiles mit 2 Schichten.
\begin{lstlisting}
-- Variable Rse mit dem Wert 0.04 und der Latex Darstellung r_{se}
rse = tVar:New(0.04,"r_{se}")
rsi = tVar:New(0.13,"r_{si}")

d1 = tVar:New(20,"d_{1}")
lambda1 = tVar:New(0.035,"\\lambda_{1}")

d2 = tVar:New(10,"d_{2}")
lambda2 = tVar:New(0.5,"\\lambda_{2}")

R = rse+d1/lambda1+d2/lambda2+rsi

-- R:bracR() erzeugt Rundeklammern und den Therm R
U=R:bracR()^(-1)
-- Bei der Ausgabe wird zuerst der Name der Var. angezeigt. Festlegen auf U
U:setName("U") = "U"
U:setUnit("\\frac{m^2K}{W}")
\end{lstlisting}
\begin{luacode*}
	rse = tVar:New(0.04,"r_{se}") -- Variable Rse mit dem Wert 0.04 und der Latex Darstellung r_{se}
	rsi = tVar:New(0.13,"r_{si}")

	d1 = tVar:New(10,"d_{1}")
	lambda1 = tVar:New(0.035,"\\lambda_{1}")

	d2 = tVar:New(10,"d_{2}")
	lambda2 = tVar:New(0.5,"\\lambda_{2}")

	R = rse+d1/lambda1+d2/lambda2+rsi

	U=R:bracR()^(-1) -- R:bracR() erzeugt Runde Klammern und den Therm R
	U:setName("U") -- Bei der Ausgabe wird zuerst der Name der Var. angezeigt. Festlegen auf U
	U:setUnit("\\frac{m^2K}{W}")
\end{luacode*}
Output mit \lstinline{U:outFull()}:
	\directlua{U:outFull()}
Output mit \lstinline{U:outHalf()}:
	\directlua{U:outHalf()}
Output mit \lstinline{U:outVar()}:
	\directlua{U:outVar()}
	\newpage
\section{Vergleichsspannung}
Berechnung der Vergleichsspannung bei gegebenem $\sigma_{x}$ und $\tau_{xy}$
\begin{luacode*}
	sigma_x = tVar:New(11.4,"\\sigma_{x}")
	tau_xy = tVar:New(2.43,"\\tau_{xy}")

	sigma_v = tVar.sqrt(sigma_x^2+3*tau_xy^2,2)
	sigma_v:setName("\\sigma_{v}")
\end{luacode*}
\begin{lstlisting}
sigma_x = tVar:New(11.4,"\\sigma_{x}")
tau_xy = tVar:New(2.43,"\\tau_{xy}")

-- tVar.sqrt([tVar],[Number])
sigma_v = tVar.sqrt(sigma_x^2+3*tau_xy^2,2)
sigma_v:setName("\\sigma_{v}")
\end{lstlisting}
Output mit \lstinline{sigma_v:outFull()}:
\directlua{sigma_v:outFull()}
\subsection{Resultierende Kraft}
Berechnen der resultierenden Kraft auf einen Kreisquerschnitt.
\begin{luacode*}
	r = tVar:New(10,"r")

	A=r^2*tVar.PI
	F=sigma_v*A
	F:setName("F")
\end{luacode*}
\begin{lstlisting}
r = tVar:New(10,"r")

A=r^2*tVar.PI
F=sigma_v*A
F:setName("F")
\end{lstlisting}
Output mit \lstinline{F:outFull()}:
	\directlua{F:outFull()}
Ausführen mit \lstinline{sigma_v:fix()}:
\begin{luacode*}
	sigma_v:fix()
	A=r^2*tVar.PI
	F=sigma_v*A
	F:setName("F")
\end{luacode*}
\begin{lstlisting}
-- fix() löscht die Berechnungsschritte einer Var., damit wird bei jedem Aufruf der Var. nur mehr der Name angezeigt
sigma_v:fix()
A=r^2*tVar.PI
F=sigma_v*A
F:setName("F")
\end{lstlisting}
Output mit \lstinline{F:outFull()}:
	\directlua{F:outFull()}
\section{Matrizen}
\subsection{Addition und Subtraktion}
\begin{lstlisting}
-- Definition durch 2-Dimensionales Array
A=tMat:New({{10,2,5,3},{2,4,3,1}},"a_{1}")
B=tMat:New({{3,1,4,1},{2,4,5,10}},"b_{1}")

-- CRLF() fuegt eine Zeilenumbruch ein und achtet auf Klammergroeszen
C = A + B:CRLF() -A
C:setName("C")
\end{lstlisting}
\begin{luacode*}
A=tMat:New({{10,2,5,3},{2,4,3,1}},"a_{1}")
B=tMat:New({{3,1,4,1},{2,4,5,10}},"b_{1}")
C = A + B:CRLF() -A
C:setName("C")
\end{luacode*}
Output mit \lstinline{C:outFull()}:
\directlua{C:outFull()}
\subsection{Multiplikation and Division}
\begin{lstlisting}
A=tMat:New({{10,2,5,3},{2,4,3,1}},"a_{1}	")
B=tMat:New({{3,1},{4,2},{5,8},{2,9}},"b_{1}")
D=tMat:New({{5,12.2},{3,22}},"D")

-- Uebergabe Paramter fuer CRLF wird ab ende der Zeile und am Anfang der naechsten Angezeigt
C = A:CRLF("\\cdot") * (B*2) - D/2
C=-C:bracR()
C:setName("C")
\end{lstlisting}
\begin{luacode*}
A=tMat:New({{10,2,5,3},{2,4,3,1}},"a_{1}	")
B=tMat:New({{3,1},{4,2},{5,8},{2,9}},"b_{1}")
D=tMat:New({{5,12.2},{3,22}},"D")
C = A:CRLF("\\cdot") * (B*2) - D/2
C=-C:bracR()
C:setName("C")
\end{luacode*}
Output mit \lstinline{C:outFull()}:
\directlua{C:outFull()}
\subsection{Transponieren}
\begin{lstlisting}
A=tMat:New({{10,2,5,3},{2,4,3,1}},"a_{1}")
C = A:T()
C:setName("C")
\end{lstlisting}
\begin{luacode*}
A=tMat:New({{10,2,5,3},{2,4,3,1}},"a_{1}")
C = A:T()
C:setName("C")
\end{luacode*}
Output mit \lstinline{C:outFull()}:
\directlua{C:outFull()}
\subsection{Determinante und Inverse}
\begin{lstlisting}
A_2=tMat:New({{10,2,5},{2,4,3},{7,4,3}},"a_{2}")
C = A_2:Det()
Inv = A_2:Inv() * A_2:CRLF("=")
C:setName("C")
Inv:setName("Inv")
\end{lstlisting}
\begin{luacode*}
A_2=tMat:New({{10,2,5},{2,4,3},{7,4,3}},"a_{2}")
C = A_2:Det()
Inv = A_2:Inv() * A_2:CRLF("=")
C:setName("C")
Inv:setName("Inv")
\end{luacode*}
Output mit \lstinline{C:outFull()}:
\directlua{C:outFull()}
Output mit \lstinline{Inv:outFull()}:
\directlua{Inv:outFull()}
\section{Vektor Operationen}
\subsection{Addition und Subtraktion}
\begin{lstlisting}
v_1=tVec:New({10,2,7},"v_{1}")
v_2=tVec:New({3,1,2},"v_{2}")
v_3 = (v_1+v_2):bracR()-v_2
v_3:setName("v_{3}")
\end{lstlisting}
\begin{luacode*}
	v_1=tVec:New({10,2,7},"v_{1}")
	v_2=tVec:New({3,1,2},"v_{2}")
	v_3 = (v_1+v_2):bracR()-v_2
	v_3:setName("v_{3}")
\end{luacode*}
Output mit \lstinline{v_3:outFull()}:
\directlua{v_3:outFull()} \\
Nur den Wert Ausgeben mit \lstinline{v_3:out()}:
\directlua{v_3:out()}
\subsection{Skalarprodukt und Produkt mit einem Skalar}
Ist zur Zeit nur mit $R3$ Vektoren möglich.
\begin{lstlisting}
v_1=tVec:New({10,2,7},"v_{1}")
v_2=tVec:New({3,1,2},"v_{2}")
v_3 = (v_1*2):bracR()*v_2
v_3:setName("v_{3}")
\end{lstlisting}
\begin{luacode*}
	v_1=tVec:New({10,2,7},"v_{1}")
	v_2=tVec:New({3,1,2},"v_{2}")
	v_3 = (v_1*2):bracR()*v_2
	v_3:setName("v_{3}")
\end{luacode*}
Output mit \lstinline{v_3:outFull()}:
\directlua{v_3:outFull()}
\subsection{Kreuzprodukt}
Ist zur Zeit nur mit $R3$ Vektoren möglich.
\begin{lstlisting}
v_1=tVec:New({10,2,7},"v_{1}")
v_2=tVec:New({3,1,2},"v_{2}")
v_3 = v_1:crossP(v_2)
v_3:setName("v_{3}")
\end{lstlisting}
\begin{luacode*}
	v_1=tVec:New({10,2,7},"v_{1}")
	v_2=tVec:New({3,1,2},"v_{2}")
	v_3 = v_1:crossP(v_2)
	v_3:setName("v_{3}")
\end{luacode*}
Output mit \lstinline{v_3:outFull()}:
\directlua{v_3:outFull()}
\newpage
\section{Befehlsreferenz}
Wenn nicht anders angegeben, sind alle Befehle entsprechen der Hierarchie \textbf{tVar}~\Rightarrow~\textbf{tMat}~\Rightarrow~\textbf{tVec} vererbt.
\begin{table}[ht]
\begin{tabular}{|p{0.4\textwidth}|p{0.6\textwidth}|}
	\hline
	\multicolumn{2}{|c|}{\textbf{tVar}}\\
	\hline
	\lstinline{tVar.numFormat = [format]} & Definiert das Ausgabe-Zahlenformat \lstinline{[latex]}. \newline \lstinline!tVar.numFormat = "%.3f"!\\
	\hline
	\lstinline{tVar:New([value],[latex])} & Erzeugt eine neue Variable mit dem Wert \lstinline{[value]} und der Latex Darstellung \lstinline{[latex]}. \newline \lstinline!rse= tVar:New(0.04,"r_{se}")!\\
	\hline
	\lstinline{[tVar]:setName([latex])} & Legt die Latex Darstellung für einen berechneten Wert fest.  \newline \lstinline!U:setName("U")!\\
	\hline
	\lstinline{[tVar]:setUnit([latex])} & Legt die Latex Darstellung für die Einheit fest.  \newline \lstinline!U:setUnit("mm")!\\
	\hline
	\lstinline{[tVar]:bracR()} & Umschlie\ss t die Formeldarstellung der Variable [tVar] mit runden Klammer.  \newline \lstinline!U = R:bracR() !\\
	\hline
	\lstinline{tVar.sqrt([tVar],[number])} & [numbert]te Wurzel aus [tVar]  \newline \lstinline!sigma_v = tVar.sqrt(sigma_x^2+3*tau_xy^2,2)!\\
	\hline
	\lstinline{[tVar].debugMode = "on"||"off"} & Ausgabe der generierten \LaTeX-Kommandos \newline Global: \lstinline!tVar.debugMode = "on"! \\
		\hline
			\lstinline{[tVar].mathEnviroment = [string]} & Festlegen der Math-Umgebung. Default: align. Wenn "" dann keine Umgebung.\\
			\hline
		\lstinline{tVar.PI} & $\pi$  \newline \lstinline!A=r^2*tVar.PI!\\
		\hline
		\lstinline{[tVar]:fix([latex])} & Bereinigt die Variable von Berechnungsschritten, damit wird bei einer Rechenoperation nicht mehr die Gleichung verwendet sondern die Bezeichnung. [latex] Latex Darstellung (Optional)\newline \lstinline!A:fix()!\\
		\hline
		\lstinline{[tVar]:CRLF([string])} &Macht einen Zeilenumbruch an der Stelle in der Formel. [string] Optional. Zeichen wird am Ende der Zeile und am Anfang der neune Zeile eingefügt.\newline \lstinline!C = A + B:CRLF("-") - A!\\
		\hline

	\end{tabular}
\end{table}
\begin{table}[ht]
	\begin{tabular}{|p{0.4\textwidth}|p{0.6\textwidth}|}
		\hline
				\lstinline{[tVar]:outFull([bool],[bool])} & Ausgabe: Name=Gleichung=Gleichung mit Werten=Ergebnis. [bool] nummeriert für true. [bool](2) ohne enviroment für false.  \newline \lstinline!U:outFull(true) !\\
				\hline
		\hline
		\lstinline{[tVar]:outHalf([bool],[bool])} & Ausgabe: Name=Gleichung=Ergebnis. [bool] nummeriert für true. [bool](2) ohne enviroment für false. \newline \lstinline!U:outHalf(true) !\\
		\hline
		\lstinline{[tVar]:outVar([bool],[bool])} & Ausgabe: Name=Ergebnis. [bool](1) nummeriert für true. [bool](2) ohne enviroment für false.  \newline \lstinline!U:outVar(false,true) !\\
		\hline
		\lstinline{[tVar]:out()} & Ausgabe: Ergebnis (Inline).\newline \lstinline!U:out() !\\
		\hline

		\hline
		\multicolumn{2}{|c|}{\textbf{tMat}}\\
		\hline
		\lstinline{tMat:New([value],[latex])} & Erzeugt eine neue Matrix-Variable mit dem Wert \lstinline{[value]} und der Latex Darstellung \lstinline{[latex]}.\newline \lstinline!A_2=tMat:New({{10,2,5},{2,4,3},{7,4,3}},"a_{2}")!\\
		\hline
		\lstinline{[tMat]:T()} & Matrix Transponieren \newline \lstinline!C=A:T()!\\
		\hline
		\lstinline{[tMat]:Det()} & Matrix Determinante \newline \lstinline!C=A:Det()!\\
		\hline
		\lstinline{[tMat]:Inv()} & Matrix Inverse \newline \lstinline!C=A:Inv()!\\
		\hline
		\multicolumn{2}{|c|}{\textbf{tVec}}\\
		\hline
		\lstinline{tVec:New([value],[latex])} & Erzeugt eine neue Vektor-Variable mit dem Wert \lstinline{[value]} und der Latex Darstellung \lstinline{[latex]}.\newline \lstinline!v_1=tVec:New({10,2,7},"v_{1}")!\\
		\hline
		\lstinline{[tVec]:crossP([tVec])} & Kreuzprodukt zweier Vektoren \newline \lstinline!v_3=v_1:crossP(v_2)!\\
		\hline
	\end{tabular}
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
